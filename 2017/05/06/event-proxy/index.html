<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="keywords" content="前端周记,前端开发,前端分享,前端实践,FE,Front End,React,React Native,NodeJS,Vue,Electron"><meta name="description" content="前端周记,前端分享,前端实践,前端技术文章翻译,项目总结,知识点记录,心得体会分享,新技术调研。好记性不如烂笔头,记录自己做项目过程中的一些心得体会,遇到过并填过的坑以及自平时己学习的新知识,摸过的鱼。"><meta name="baidu-site-verification" content="gC9bUYul0P"><title>eventproxy 源码解析 | ~Refresh的前端之路</title><link rel="stylesheet" type="text/css" href="https://blog.wfuny.com/css/style.css?v=1.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">eventproxy 源码解析</h1><a id="logo" href="/.">~Refresh的前端之路</a><p class="description">一条道走到黑</p></div><div id="nav-menu"><a href="/." class="current"><span class="icon icon-home"></span><span class="menu-txt">首页</span></a><a href="/archives/"><span class="icon icon-archive"></span><span class="menu-txt">归档</span></a><a href="/about/"><span class="icon icon-about"></span><span class="menu-txt">关于</span></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><!--if page.type == 'original'--><!--  div.watermark.original--><!--if page.type == 'translate'--><!--  div.watermark.translate--><!--if page.type == 'recommend'--><!--  div.watermark.recommend--><h1 class="post-title">eventproxy 源码解析</h1><div class="post-meta">May 6, 2017<span> | </span><span class="category"><a href="/categories/NodeJS/">NodeJS</a><a href="/categories/NodeJS/nodeclub源码学习/">nodeclub源码学习</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：</p>
<ol>
<li>利用事件机制解耦复杂业务逻辑</li>
<li>移除被广为诟病的深度callback嵌套问题</li>
<li>将串行等待变成并行等待，提升多异步协作场景下的执行效率</li>
<li>友好的Error handling</li>
<li>无平台依赖，适合前后端，能用于浏览器和Node.js</li>
<li>兼容CMD，AMD以及CommonJS模块环境</li>
</ol>
<p>在nodeclub源码中有一段实现代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// nodeclub 首页路由处理函数</span></div><div class="line">exports.index = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> page = <span class="built_in">parseInt</span>(req.query.page, <span class="number">10</span>) || <span class="number">1</span>;</div><div class="line">  page = page &gt; <span class="number">0</span> ? page : <span class="number">1</span>;</div><div class="line">  <span class="keyword">var</span> tab = req.query.tab || <span class="string">'all'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> proxy = <span class="keyword">new</span> eventproxy();</div><div class="line">  proxy.fail(next);</div><div class="line"></div><div class="line">  <span class="comment">// 取主题</span></div><div class="line">  <span class="keyword">var</span> query = &#123;&#125;;</div><div class="line">  <span class="keyword">if</span> (!tab || tab === <span class="string">'all'</span>) &#123;</div><div class="line">    query.tab = &#123;<span class="attr">$ne</span>: <span class="string">'job'</span>&#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> (tab === <span class="string">'good'</span>) &#123;</div><div class="line">      query.good = <span class="literal">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      query.tab = tab;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> limit = config.list_topic_count;</div><div class="line">  <span class="keyword">var</span> options = &#123; <span class="attr">skip</span>: (page - <span class="number">1</span>) * limit, <span class="attr">limit</span>: limit, <span class="attr">sort</span>: <span class="string">'-top -last_reply_at'</span>&#125;;</div><div class="line"></div><div class="line">  Topic.getTopicsByQuery(query, options, proxy.done(<span class="string">'topics'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">topics</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> topics;</div><div class="line">  &#125;));</div><div class="line"></div><div class="line">  <span class="comment">// 取排行榜上的用户</span></div><div class="line">  cache.get(<span class="string">'tops'</span>, proxy.done(<span class="function"><span class="keyword">function</span> (<span class="params">tops</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tops) &#123;</div><div class="line">      proxy.emit(<span class="string">'tops'</span>, tops);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      User.getUsersByQuery(</div><div class="line">        &#123;<span class="attr">is_block</span>: <span class="literal">false</span>&#125;,</div><div class="line">        &#123; <span class="attr">limit</span>: <span class="number">10</span>, <span class="attr">sort</span>: <span class="string">'-score'</span>&#125;,</div><div class="line">        proxy.done(<span class="string">'tops'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">tops</span>) </span>&#123;</div><div class="line">          cache.set(<span class="string">'tops'</span>, tops, <span class="number">60</span> * <span class="number">1</span>);</div><div class="line">          <span class="keyword">return</span> tops;</div><div class="line">        &#125;)</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">  <span class="comment">// END 取排行榜上的用户</span></div><div class="line"></div><div class="line">  <span class="comment">// 取0回复的主题</span></div><div class="line">  cache.get(<span class="string">'no_reply_topics'</span>, proxy.done(<span class="function"><span class="keyword">function</span> (<span class="params">no_reply_topics</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (no_reply_topics) &#123;</div><div class="line">      proxy.emit(<span class="string">'no_reply_topics'</span>, no_reply_topics);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      Topic.getTopicsByQuery(</div><div class="line">        &#123; <span class="attr">reply_count</span>: <span class="number">0</span>, <span class="attr">tab</span>: &#123;<span class="attr">$ne</span>: <span class="string">'job'</span>&#125;&#125;,</div><div class="line">        &#123; <span class="attr">limit</span>: <span class="number">5</span>, <span class="attr">sort</span>: <span class="string">'-create_at'</span>&#125;,</div><div class="line">        proxy.done(<span class="string">'no_reply_topics'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">no_reply_topics</span>) </span>&#123;</div><div class="line">          cache.set(<span class="string">'no_reply_topics'</span>, no_reply_topics, <span class="number">60</span> * <span class="number">1</span>);</div><div class="line">          <span class="keyword">return</span> no_reply_topics;</div><div class="line">        &#125;));</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">  <span class="comment">// END 取0回复的主题</span></div><div class="line"></div><div class="line">  <span class="comment">// 取分页数据</span></div><div class="line">  <span class="keyword">var</span> pagesCacheKey = <span class="built_in">JSON</span>.stringify(query) + <span class="string">'pages'</span>;</div><div class="line">  cache.get(pagesCacheKey, proxy.done(<span class="function"><span class="keyword">function</span> (<span class="params">pages</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pages) &#123;</div><div class="line">      proxy.emit(<span class="string">'pages'</span>, pages);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      Topic.getCountByQuery(query, proxy.done(<span class="function"><span class="keyword">function</span> (<span class="params">all_topics_count</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> pages = <span class="built_in">Math</span>.ceil(all_topics_count / limit);</div><div class="line">        cache.set(pagesCacheKey, pages, <span class="number">60</span> * <span class="number">1</span>);</div><div class="line">        proxy.emit(<span class="string">'pages'</span>, pages);</div><div class="line">      &#125;));</div><div class="line">    &#125;</div><div class="line">  &#125;));</div><div class="line">  <span class="comment">// END 取分页数据</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> tabName = renderHelper.tabName(tab);</div><div class="line">  proxy.all(<span class="string">'topics'</span>, <span class="string">'tops'</span>, <span class="string">'no_reply_topics'</span>, <span class="string">'pages'</span>,</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">topics, tops, no_reply_topics, pages</span>) </span>&#123;</div><div class="line">      res.render(<span class="string">'index'</span>, &#123;</div><div class="line">        <span class="attr">topics</span>: topics,</div><div class="line">        <span class="attr">current_page</span>: page,</div><div class="line">        <span class="attr">list_topic_count</span>: limit,</div><div class="line">        <span class="attr">tops</span>: tops,</div><div class="line">        <span class="attr">no_reply_topics</span>: no_reply_topics,</div><div class="line">        <span class="attr">pages</span>: pages,</div><div class="line">        <span class="attr">tabs</span>: config.tabs,</div><div class="line">        <span class="attr">tab</span>: tab,</div><div class="line">        <span class="attr">pageTitle</span>: tabName &amp;&amp; (tabName + <span class="string">'版块'</span>),</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>代码中看到了 <code>proxy.emit(&#39;ev&#39;)</code> , <code>proxy.done(&#39;ev&#39;,fn)</code>,<code>proxy.fail(next)</code> 所以要看懂这段代码,就必须了解eventproxy使用方法(当然可以猜测具体的作用)。查看了GitHub上的README,遗憾的是api文档现在不能正常访问了,出于学习的态度,简单的阅读了源码实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params">name, definition</span>) </span>&#123;</div><div class="line">  <span class="comment">// Check define</span></div><div class="line">  <span class="keyword">var</span> hasDefine = <span class="keyword">typeof</span> define === <span class="string">'function'</span>,</div><div class="line">    <span class="comment">// Check exports</span></div><div class="line">    hasExports = <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">module</span>.exports;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (hasDefine) &#123;</div><div class="line">    <span class="comment">// AMD Module or CMD Module</span></div><div class="line">    define(<span class="string">'eventproxy_debug'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;&#125;); <span class="comment">// 定义一个eventproxy_debug 模块，返回一个空函数作为debug函数。</span></div><div class="line">    define([<span class="string">'eventproxy_debug'</span>], definition); <span class="comment">// 依赖前面定义的模块，作为debug参数传入definition中。</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasExports) &#123;</div><div class="line">    <span class="comment">// Node.js Module</span></div><div class="line">    <span class="built_in">module</span>.exports = definition(<span class="built_in">require</span>(<span class="string">'debug'</span>)(<span class="string">'eventproxy'</span>));</div><div class="line">    <span class="comment">// debug 模块，一个简单的输出调试信息模块</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Assign to common namespaces or simply the global object (window)</span></div><div class="line">    <span class="keyword">this</span>[name] = definition();</div><div class="line">  &#125;</div><div class="line">&#125;)(<span class="string">'EventProxy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">debug</span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先是定义了一系列的环境支持。像AMD,CMD,UMD,CommonJS。EventProxy 是最终的模块名称,真正的定义需要传入一个debug函数。其实就是日志输出工具,接下来就是具体的定义和实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.addListener = <span class="function"><span class="keyword">function</span>(<span class="params">ev, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">//....</span></div><div class="line">&#125;</div><div class="line">EventProxy.prototype.bind = EventProxy.prototype.addListener;</div><div class="line">EventProxy.prototype.on = EventProxy.prototype.addListener;</div><div class="line">EventProxy.prototype.subscribe = EventProxy.prototype.addListener;</div></pre></td></tr></table></figure>
<p>注册事件函数和它的一系列别名,别名也是挺多的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.headbind = <span class="function"><span class="keyword">function</span> (<span class="params">ev, callback</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    debug(<span class="string">'Add listener for %s'</span>, ev);</div><div class="line">    <span class="keyword">this</span>._callbacks[ev] = <span class="keyword">this</span>._callbacks[ev] || [];</div><div class="line">    <span class="keyword">this</span>._callbacks[ev].unshift(callback);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码比较简单,直接说下具体的作用吧,headbind 顾名思义,就是绑定的同时通过数组的unshift函数将事件回调函数放在最前面,接下来是解绑事件函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">eventname, callback</span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> calls = <span class="keyword">this</span>._callbacks;</div><div class="line">   <span class="keyword">if</span> (!eventname) &#123;</div><div class="line">     debug(<span class="string">'Remove all listeners'</span>);</div><div class="line">     <span class="keyword">this</span>._callbacks = &#123;&#125;;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="keyword">if</span> (!callback) &#123;</div><div class="line">       debug(<span class="string">'Remove all listeners of %s'</span>, eventname);</div><div class="line">       calls[eventname] = [];</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">var</span> list = calls[eventname];</div><div class="line">       <span class="keyword">if</span> (list) &#123;</div><div class="line">         <span class="keyword">var</span> l = list.length;</div><div class="line">         <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (callback === list[i]) &#123;</div><div class="line">             debug(<span class="string">'Remove a listener of %s'</span>, eventname);</div><div class="line">             list[i] = <span class="literal">null</span>;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这个函数作用很简单就是删除(其实是对数组中相应元素下标置为null)绑定的事件回调函数,如果没有指明删除具体哪个回调函数 callback ，则删除这个事件上绑定的所有回调函数,如果连eventname都没有提供则删除所有事件上绑定的所有回调函数,这个方法的别名,<code>unbind</code>。还有根据前面两个绑定和解绑衍生出来的几个方法,<code>removeAllListeners</code>,<code>bindForAll</code>,<code>unbindForAll</code>。 在all事件上绑定处理函数,意味着任何事件触发都会执行all事件上的回调函数,下面源码一看就一目了然了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.trigger = <span class="function"><span class="keyword">function</span> (<span class="params">eventname, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> list, ev, callback, i, l;</div><div class="line">    <span class="keyword">var</span> both = <span class="number">2</span>; <span class="comment">// 设置为2的目的是，第一次先执行具体事件上的回调函数，第二次执行绑定在ALL_EVENT上的回调函数。</span></div><div class="line">    <span class="keyword">var</span> calls = <span class="keyword">this</span>._callbacks;</div><div class="line">    debug(<span class="string">'Emit event %s with data %j'</span>, eventname, data);</div><div class="line">    <span class="keyword">while</span> (both--) &#123;</div><div class="line">      ev = both ? eventname : ALL_EVENT;</div><div class="line">      list = calls[ev];</div><div class="line">      <span class="keyword">if</span> (list) &#123;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, l = list.length; i &lt; l; i++) &#123;</div><div class="line">          <span class="keyword">if</span> (!(callback = list[i])) &#123; <span class="comment">//如果callback为null，回调函数数组中剔除空元素，修正循环下标和数组长度。</span></div><div class="line">            list.splice(i, <span class="number">1</span>);</div><div class="line">            i--;</div><div class="line">            l--;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">var</span> args = [];</div><div class="line">            <span class="keyword">var</span> start = both ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 如果是具体事件上的回调函数执行，参数不包括事件名称，如果是ALL_EVENT上的回调函数</span></div><div class="line">            <span class="comment">//执行，参数包括事件名称。</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = start; j &lt; <span class="built_in">arguments</span>.length; j++) &#123;</div><div class="line">              args.push(<span class="built_in">arguments</span>[j]);</div><div class="line">            &#125;</div><div class="line">            callback.apply(<span class="keyword">this</span>, args);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>both 设置成2,就是执行完一次对于事件回调函数后,还要再执行一次all事件上的回调函数,也是很嗨的。然后它的别名也是蛮多的,<code>emit</code>,<code>fire</code>,所以最上面源码中的<code>proxy.emit</code>也就知道作用了。接下来继续看源代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">ev, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="comment">//包装回调函数，执行完后自己解绑。</span></div><div class="line">  <span class="keyword">var</span> wrapper = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    callback.apply(self, <span class="built_in">arguments</span>);</div><div class="line">    self.unbind(ev, wrapper);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">this</span>.bind(ev, wrapper);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过对callback 进行一层包装,包装后的函数会在运行callback后 <code>self.unbind(ev, wrapper);</code> 进行自我解绑,从而使得callback只会触发执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法使用优先级 setImmediate -&gt; nextTick -&gt; setTimeout</span></div><div class="line"> <span class="keyword">var</span> later = (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; setImmediate) ||</div><div class="line">   (<span class="keyword">typeof</span> process !== <span class="string">'undefined'</span> &amp;&amp; process.nextTick) || <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">   setTimeout(fn, <span class="number">0</span>);</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这里定义了异步方法,各个方法的区别和有关事件循环的内容可以参看我总结的另一篇文章<a href="http://weeklyweb.info/2017/05/05/fe-event-loop/" target="_blank" rel="external">JavaScript &amp; NodeJS 事件循环</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//使得触发事件行为变成异步</span></div><div class="line">EventProxy.prototype.emitLater = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">  later(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    self.trigger.apply(self, args);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不知道emitLater这个方法使用场景,根据代码可以知道就是延迟触发事件,不明觉厉了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绑定完事件回调后立马先触发一次</span></div><div class="line">EventProxy.prototype.immediate = <span class="function"><span class="keyword">function</span> (<span class="params">ev, callback, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.bind(ev, callback); <span class="comment">// 绑定事件</span></div><div class="line">  <span class="keyword">this</span>.trigger(ev, data); <span class="comment">// 立马触发</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line">EventProxy.prototype.asap = EventProxy.prototype.immediate;</div></pre></td></tr></table></figure>
<p>immediate 方法和它的别名asap,作用就是绑定事件函数后立马执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _assign = <span class="function"><span class="keyword">function</span> (<span class="params">eventname1, eventname2, cb, once</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> proxy = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> argsLength = <span class="built_in">arguments</span>.length;</div><div class="line">  <span class="keyword">var</span> times = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> flag = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Check the arguments length.</span></div><div class="line">  <span class="comment">//必须提供至少3个参数</span></div><div class="line">  <span class="keyword">if</span> (argsLength &lt; <span class="number">3</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> events = SLICE.call(<span class="built_in">arguments</span>, <span class="number">0</span>, <span class="number">-2</span>);</div><div class="line">  <span class="keyword">var</span> callback = <span class="built_in">arguments</span>[argsLength - <span class="number">2</span>];</div><div class="line">  <span class="keyword">var</span> isOnce = <span class="built_in">arguments</span>[argsLength - <span class="number">1</span>];</div><div class="line"></div><div class="line">  <span class="comment">// Check the callback type.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  debug(<span class="string">'Assign listener for events %j, once is %s'</span>, events, !!isOnce);</div><div class="line">  <span class="keyword">var</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">//计数 收集数据</span></div><div class="line">    <span class="keyword">var</span> method = isOnce ? <span class="string">"once"</span> : <span class="string">"bind"</span>;</div><div class="line">    proxy[method](key, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">      proxy._fired[key] = proxy._fired[key] || &#123;&#125;;</div><div class="line">      proxy._fired[key].data = data;</div><div class="line">      <span class="keyword">if</span> (!flag[key]) &#123;</div><div class="line">        flag[key] = <span class="literal">true</span>;</div><div class="line">        times++;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> length = events.length;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">    bind(events[index]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> _all = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (times &lt; length) &#123; <span class="comment">// 用来保证是否所有事件都已经触发过</span></div><div class="line">      <span class="keyword">return</span>; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!flag[event]) &#123; <span class="comment">// 确保是提供的参数中包含的事件被触发</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> data = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</div><div class="line">      data.push(proxy._fired[events[index]].data); <span class="comment">// 收集所有数据</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isOnce) &#123; <span class="comment">// 是否只需要触发一次</span></div><div class="line">      proxy.unbindForAll(_all);</div><div class="line">    &#125;</div><div class="line">    debug(<span class="string">'Events %j all emited with data %j'</span>, events, data);</div><div class="line">    callback.apply(<span class="literal">null</span>, data); <span class="comment">// 调用回调函数</span></div><div class="line">  &#125;;</div><div class="line">  proxy.bindForAll(_all); <span class="comment">// 将新够造的回调函数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该方法的作用是收集前面事件触发后传给回调函数的数据，然后最后构成一个数据数组，传给callback（cb）如果调用时传入的 once 为 true,则这个callback 只会被调用一次否则会多次被调用。这个方法是一个内部方法,其中暴露给用户使用的是下面的方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">eventname1, eventname2, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = CONCAT.apply([], <span class="built_in">arguments</span>);</div><div class="line">  args.push(<span class="literal">true</span>);</div><div class="line">  _assign.apply(<span class="keyword">this</span>, args); </div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line">EventProxy.prototype.assign = EventProxy.prototype.all;</div><div class="line"></div><div class="line">EventProxy.prototype.tail = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = CONCAT.apply([], <span class="built_in">arguments</span>);</div><div class="line">    args.push(<span class="literal">false</span>);</div><div class="line">    _assign.apply(<span class="keyword">this</span>, args);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line">EventProxy.prototype.assignAll = EventProxy.prototype.tail;</div><div class="line">EventProxy.prototype.assignAlways = EventProxy.prototype.tail;</div></pre></td></tr></table></figure>
<ul>
<li><p>all 方法,别名 assign </p>
<p>  绑定一系列事件，当这些事件都触发了，callback会被执行一次,执行完就解绑自己,所以后续不会再被触发执行。</p>
</li>
<li><p>tail 方法,别名 assignAll , assignAlways</p>
<p>  绑定一些事件，当所有事件都触发了，callback 会被触发，以后只要这些事件中的事件再次被触发，callback都会被执行。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">EventProxy.prototype.fail = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">   that.once(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     that.unbind();</div><div class="line">     <span class="comment">// put all arguments to the error handler</span></div><div class="line">     <span class="comment">// fail(function(err, args1, args2, ...)&#123;&#125;)</span></div><div class="line">     callback.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">   &#125;);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> EventProxy.prototype.throw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">   that.emit.apply(that, [<span class="string">'error'</span>].concat(SLICE.call(<span class="built_in">arguments</span>)));</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>fail 方法</p>
<p>绑定事件到error上,当出现error事件的时候,执行回调函数,并解绑所有的事件绑定。</p>
</li>
<li><p>throw </p>
<p>error 事件触发的缩写。通过throw方法,就可以触发fail方法绑定的回调函数,这里<code>proxy.fail(next)</code>,这边错误发生执行的回调函数就是next。</p>
</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">  EventProxy.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">handler, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">//重新返回一个回调函数</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="comment">// put all arguments to the error handler</span></div><div class="line">        <span class="comment">// 如果出现错误,则直接出发erorr事件,并返回</span></div><div class="line">        <span class="keyword">return</span> that.emit.apply(that, [<span class="string">'error'</span>].concat(SLICE.call(<span class="built_in">arguments</span>)));</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// callback(err, args1, args2, ...)</span></div><div class="line">      <span class="comment">// 获取到数据,剔除err参数</span></div><div class="line">      <span class="keyword">var</span> args = SLICE.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">      </div><div class="line">      <span class="comment">// 如果handler是字符串</span></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="comment">// getAsync(query, ep.done('query'));</span></div><div class="line">        <span class="comment">// or</span></div><div class="line">        <span class="comment">// getAsync(query, ep.done('query', function (data) &#123;</span></div><div class="line">        <span class="comment">//   return data.trim();</span></div><div class="line">        <span class="comment">// &#125;));</span></div><div class="line">        <span class="comment">//存在callback</span></div><div class="line">        <span class="keyword">if</span> (callback) &#123;</div><div class="line">          <span class="comment">// 获取 callback 处理的数据。</span></div><div class="line">          <span class="comment">// only replace the args when it really return a result</span></div><div class="line">          <span class="keyword">return</span> that.emit(handler, callback.apply(<span class="literal">null</span>, args));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// put all arguments to the done handler</span></div><div class="line">          <span class="comment">//ep.done('some');</span></div><div class="line">          <span class="comment">//ep.on('some', function(args1, args2, ...)&#123;&#125;);</span></div><div class="line">          <span class="comment">// 如果callback 未提供,直接触发事件,参数为新回调函数获取到的内容</span></div><div class="line">          <span class="keyword">return</span> that.emit.apply(that, [handler].concat(args));</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// speed improve for mostly case: `callback(err, data)`</span></div><div class="line">      <span class="comment">// 如果handler提供的是function 且 则直接执行</span></div><div class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt;= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> handler(data);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// callback(err, args1, args2, ...)</span></div><div class="line">      handler.apply(<span class="literal">null</span>, args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>done 方法</p>
<p>事件回调包装函数,handler 事件名称,callback 结果数据处理函数,返回新的结果数据。具体解释参看源码中的注释,主要分几种情况:</p>
<ul>
<li><p>handler 参数提供且为字符串</p>
<ol>
<li><p>如果提供了 callback 结果处理函数</p>
<p>调用 <code>that.emit(handler, callback.apply(null, args));</code> 作为参数的数据是经过 callback 处理后的值。</p>
</li>
<li><p>如果未提供 callback 参数</p>
<p>调用 <code>that.emit.apply(that, [handler].concat(args));</code> 数据参数为 handler 加上 args(异步操作结果数据) 。</p>
</li>
</ol>
</li>
<li><p>handler 为 Function</p>
<ol>
<li>如果异步操作结果数据的参数只有两个,类似这种情形<code>callback(err,data)</code> 则直接调用<code>handler(data);</code>。</li>
<li>如果异步操作结果数据的参数不止两个,类似<code>callback(err,arg1,arg2,...)</code> 这种,则调用<code>handler.apply(null, args);</code>。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然eventproxy的源代码比较简单,但是在阅读的过程中也添加了部分注释,有兴趣可以看下,地址:<a href="https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js" target="_blank" rel="external">https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js</a></p>
</div><script type="text/javascript" src="https://blog.wfuny.com/js/share.js?v=1.0.1" async></script><a data-url="https://blog.wfuny.com/2017/05/06/event-proxy/" data-id="cje5r40680004s77q9qnvk5ym" class="article-share-link">分享到</a><div class="tags"><a href="/tags/JavaScript/"><span class="icon icon-clip"></span><span class="name">JavaScript</span></a><a href="/tags/NodeJS/"><span class="icon icon-clip"></span><span class="name">NodeJS</span></a></div><div class="post-nav"><a href="/2017/05/08/webpack1-to-webpack2/" class="pre">升级项目中的 webpack1.x 到 webpack2.x , 完善项目构建打包</a><a href="/2017/05/05/fe-event-loop/" class="next">JavaScript 和 NodeJS 事件循环</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
  url: document.location.href,
  sourceId: "",
  productKey: "151c661ff0ff41c18669a374d3f8f153",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="搜索" type="text" name="q" results="0" autocomplete="off"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><span class="icon icon-category"></span><span class="widget-txt">分类</span></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/">NodeJS</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/nodeclub源码学习/">nodeclub源码学习</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodeclub源码学习/">nodeclub源码学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端大杂烩/">前端大杂烩</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端大杂烩/NodeJS/">NodeJS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端大杂烩/构建工具/">构建工具</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><span class="icon icon-clip"></span><span class="widget-txt">标签</span></div><div class="tagcloud"><a href="/tags/前端大杂烩/" style="font-size: 15px;">前端大杂烩</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/Mongoose/" style="font-size: 15px;">Mongoose</a> <a href="/tags/Mongodb/" style="font-size: 15px;">Mongodb</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/React-Native/" style="font-size: 15px;">React Native</a></div></div><div class="widget"><div class="widget-title"><span class="icon icon-article"></span><span class="widget-txt">最新文章</span></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/24/git-and-npm/">git 和 npm 常用命令汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/webpack1-to-webpack2/">升级项目中的 webpack1.x 到 webpack2.x , 完善项目构建打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/event-proxy/">eventproxy 源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/fe-event-loop/">JavaScript 和 NodeJS 事件循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/03/javascript-event-loop/">什么是JavaScript 事件循环 ?</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/27/mongoose-tutorial-2/">Mongoose 学习笔记二 — Query 和 Population</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/react-life-cycle/">React 的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/ngrok/">使用ngrok让你的本地mock可以提供给外网访问</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/redux-introduction/">Redux 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/regular-expression/">JavaScript中的正则表达式之正向环视(正向断言)</a></li></ul></div><div class="widget"><div class="widget-title"><span class="icon icon-link"></span><span class="widget-txt">友情链接</span></div><ul></ul><a href="http://fex.baidu.com/" title="百度FEX" target="_blank">百度FEX</a><ul></ul><a href="http://www.aliued.com/" title="阿里巴巴UED" target="_blank">阿里巴巴UED</a><ul></ul><a href="http://f2e.souche.com/blog/" title="搜车大无线团队博客" target="_blank">搜车大无线团队博客</a><ul></ul><a href="http://fe.meituan.com/" title="美团前端团队博客" target="_blank">美团前端团队博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a>2018 </a><a href="/." rel="nofollow">~Refresh的前端之路</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="https://blog.wfuny.com/js/totop.js?v=1.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="https://blog.wfuny.com/js/fancybox.js?v=1.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="https://blog.wfuny.com/js/search.js?v=1.0.1"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4c66f02c419b1b8b035290646cd20eaf";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script>(function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><script type="text/javascript" src="https://blog.wfuny.com/js/codeblock-resizer.js?v=1.0.1"></script><script type="text/javascript" src="https://blog.wfuny.com/js/smartresize.js?v=1.0.1"></script></div></body></html>