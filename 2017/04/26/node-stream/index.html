<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="keywords" content="前端周记,前端开发,前端分享,前端实践,FE,Front End,React,React Native,NodeJS,Vue,Electron"><meta name="description" content="前端周记,前端分享,前端实践,前端技术文章翻译,项目总结,知识点记录,心得体会分享,新技术调研。好记性不如烂笔头,记录自己做项目过程中的一些心得体会,遇到过并填过的坑以及自平时己学习的新知识,摸过的鱼。"><meta name="baidu-site-verification" content="gC9bUYul0P"><title>Node Stream 初窥 | ~Refresh的前端之路</title><link rel="stylesheet" type="text/css" href="https://blog.wfuny.com/css/style.css?v=1.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Node Stream 初窥</h1><a id="logo" href="/.">~Refresh的前端之路</a><p class="description">一条道走到黑</p></div><div id="nav-menu"><a href="/." class="current"><span class="icon icon-home"></span><span class="menu-txt">首页</span></a><a href="/archives/"><span class="icon icon-archive"></span><span class="menu-txt">归档</span></a><a href="/about/"><span class="icon icon-about"></span><span class="menu-txt">关于</span></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Node Stream 初窥</h1><div class="post-meta">Apr 26, 2017<span> | </span><span class="category"><a href="/categories/NodeJS/">NodeJS</a><a href="/categories/NodeJS/前端大杂烩/">前端大杂烩</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>Node 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。从Node 官方文档对Stream的定义,</p>
<blockquote>
<p>A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter</p>
</blockquote>
<p>我们可以了解到 :</p>
<ul>
<li>Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作</li>
<li>Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform)</li>
<li>Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的</li>
</ul>
<p>那为什么会需要流。看下面这段代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="comment">// req is an http.IncomingMessage, which is a Readable Stream</span></div><div class="line">    <span class="comment">// res is an http.ServerResponse, which is a Writable Stream</span></div><div class="line">    fs.readFile(__dirname + <span class="string">'/data.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">        res.end(data);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8000</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>每次当请求过来,程序都会接收到这个请求,然后去读<code>data.txt</code>文件,并把内容返回。但是每次读的时候都会把<code>data.txt</code>整个读入内存,在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所以更好的办法就是需要多少给多少,而不是一股脑的将整个数据放到内存中,通过流可以实现这一的效果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;);</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">var server = http.createServer(function (req, res) &#123;</div><div class="line">    // req is an http.IncomingMessage, which is a Readable Stream</div><div class="line">    // res is an http.ServerResponse, which is a Writable Stream</div><div class="line">    var stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;);</div><div class="line">    stream.pipe(res);</div><div class="line">&#125;);</div><div class="line">server.listen(8000);</div></pre></td></tr></table></figure>
<h3 id="Node-中Stream的类型"><a href="#Node-中Stream的类型" class="headerlink" title="Node 中Stream的类型"></a>Node 中Stream的类型</h3><p>在Node.js中,有四种基本的流类型,他们分别是:<code>Readable</code> ,<code>Writable</code>,<code>Duplex</code>,<code>Transform</code>。流一般处理的数据类型都是String 和 Buffer的,但是你可以通过在创建流的时候指定选项参数<code>objectMode</code>,创建对象流,不过需要注意的是,尝试将已存在的流的模式切换成对象流是一种不安全的不被建议的操作。</p>
<p>不管是<code>Readable</code> 还是 <code>Writable</code> 流,工作的过程都会将数据保存在内部的一个缓冲区中,可以分别通过<code>readable._readableState.buffer</code> , <code>writable._writableState.getBuffer()</code> 取出buffer内容。我们可以通过选项参数<code>highWaterMark</code>控制缓冲区的大小,对于String 或者 Buffer流来说,highWaterMark 控制的字节数,对于对象流,highWaterMark控制的是对象的个数。</p>
<h4 id="1-Readable"><a href="#1-Readable" class="headerlink" title="1. Readable"></a>1. <code>Readable</code></h4><p>可读流,是输出流,通过<code>readable.push(chunk)</code>将数据读入流的缓冲区以供读取,消费者可以通过<code>readable.read()</code>读取流中的数据,如果缓冲区中的数据一直没有被消费掉,一旦到达 <code>highWaterMark</code> 设置的阈值,那么输出流就会停止往缓冲区中放数据,知道有消费者消耗掉这些数据。</p>
<blockquote>
<p>Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer).</p>
</blockquote>
<p>Readable 有两种模式,分别是 flowing 和 paused 模式。flowing 模式,会自动的从源读取数据通过事件的方式提供给应用消费,而paused 模式需要显示手动调用readable.read()方法,从流中读取数据。所有的Readable流一开始都是paused模式,但是可以通过下面的几种方法切换成flowing 模式:</p>
<ol>
<li>添加<code>data</code>事件处理器。</li>
<li>调用 <code>readable.resume()</code> 方法。</li>
<li>调用 <code>readable.pipe()</code> 方法发送数据到Writeable 流。</li>
</ol>
<p>只要监听了<code>data</code>事件或者是调用<code>readable.resume()</code>,<code>readable.pipe()</code>方法,都会将<code>readable._readableState.flowing</code> 设置为true。使得Readable当数据生成时不断的触发data事件。流程图大致如下:</p>
<p><img src="http://tech.meituan.com/img/stream-how-data-comes-out.png" alt="Readable 流程"></p>
<p>同样可以通过一些方式将模式从 flowing 切换回 paused。 具体方法参考官方文档。</p>
<h4 id="2-Writable"><a href="#2-Writable" class="headerlink" title="2. Writable"></a>2. <code>Writable</code></h4><p>可写流,输入流,是对数据写入目标的一个抽象,将内容通过<code>writable.write(chunk)</code>存入流缓冲区中,如果没有超出限制,则返回true,如果超出限制,则返回false。</p>
<ul>
<li><p>实现自己的<code>Writable</code></p>
<blockquote>
<p>继承<code>Writable</code> ,重写方法<code>_write</code>,<code>_writev</code>,任何的可写流都必须提供方法<code>_write</code>,用于将数据写入底层资源(如某个文件)。实现自己的<code>Writable</code>代码如下:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写法1:</span></div><div class="line"><span class="keyword">const</span> Writable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writable;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWritable</span> <span class="keyword">extends</span> <span class="title">Writable</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options) &#123;</div><div class="line">    <span class="comment">// Calls the stream.Writable() constructor</span></div><div class="line">    <span class="keyword">super</span>(options);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写法2:</span></div><div class="line"><span class="keyword">const</span> Writable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writable;</div><div class="line"></div><div class="line"><span class="keyword">const</span> myWritable = <span class="keyword">new</span> Writable(&#123;</div><div class="line">  write(chunk, encoding, callback) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;,</div><div class="line">  writev(chunks, callback) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Writeable 与 Readable 的关系大致如下图:</p>
<p><img src="https://segmentfault.com/img/bVoLre" alt="Writeable 与 Readable 的关系"></p>
</li>
</ul>
<h4 id="3-Duplex-amp-Transform"><a href="#3-Duplex-amp-Transform" class="headerlink" title="3. Duplex &amp; Transform"></a>3. <code>Duplex</code> &amp; <code>Transform</code></h4><p><code>Duplex</code> &amp; <code>Transform</code> 既是可读流也是可写流,类比水流管道中间部分,既有输入也有输出,输入输出分别都有各自的缓冲区。经常会有一种情况,就是输入和输出的速率不一样的情况,所以两端应该相对独立,可以为另一端调节速率。Transform 是一种特殊的 Duplex, Transform的输出以某种方式和输入相联系。Transform 内部流程图大致如下:</p>
<p><img src="https://segmentfault.com/img/bVoLri" alt="Transform 内部工作流程图"></p>
<p>gulp插件就是通过through2创建一个Transform,并执行一些操作然后返回创建的流。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://github.com/zoubin/streamify-your-node-program" target="_blank" rel="external">streamify-your-node-program</a></li>
<li><a href="https://segmentfault.com/a/1190000003479884" target="_blank" rel="external">node源码解析 – Stream探究</a></li>
<li><a href="http://tech.meituan.com/stream-internals.html" target="_blank" rel="external">Node.js Stream - 进阶篇</a></li>
<li><a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">Node Stream</a></li>
<li><a href="https://github.com/substack/stream-handbook" target="_blank" rel="external">stream-handbook</a></li>
<li><a href="https://github.com/nodejs/node/blob/master/lib/_stream_readable.js" target="_blank" rel="external">源码</a></li>
</ol>
</div><script type="text/javascript" src="https://blog.wfuny.com/js/share.js?v=1.0.1" async></script><a data-url="https://blog.wfuny.com/2017/04/26/node-stream/" data-id="cje4gdhqg000mb37qe22i97cf" class="article-share-link">分享到</a><div class="tags"><a href="/tags/NodeJS/"><span class="icon icon-clip"></span><span class="name">NodeJS</span></a></div><div class="post-nav"><a href="/2017/04/26/rn-dev-prepare/" class="pre">Mac上搭建RN开发环境</a><a href="/2017/04/26/mongoose-tutorial-1/" class="next">Mongoose 学习笔记一 Model 和 Schema</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
  url: document.location.href,
  sourceId: "",
  productKey: "151c661ff0ff41c18669a374d3f8f153",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="搜索" type="text" name="q" results="0" autocomplete="off"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><span class="icon icon-category"></span><span class="widget-txt">分类</span></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/">NodeJS</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/nodeclub源码学习/">nodeclub源码学习</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJS/前端大杂烩/">前端大杂烩</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nodeclub源码学习/">nodeclub源码学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端大杂烩/">前端大杂烩</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/构建工具/">构建工具</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/构建工具/前端大杂烩/">前端大杂烩</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><span class="icon icon-clip"></span><span class="widget-txt">标签</span></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/tags/前端大杂烩/" style="font-size: 15px;">前端大杂烩</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/npm/" style="font-size: 15px;">npm</a> <a href="/tags/Mongoose/" style="font-size: 15px;">Mongoose</a> <a href="/tags/Mongodb/" style="font-size: 15px;">Mongodb</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/React-Native/" style="font-size: 15px;">React Native</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a></div></div><div class="widget"><div class="widget-title"><span class="icon icon-article"></span><span class="widget-txt">最新文章</span></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/06/24/git-and-npm/">git 和 npm 常用命令汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/webpack1-to-webpack2/">升级项目中的 webpack1.x 到 webpack2.x , 完善项目构建打包 - 测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/06/event-proxy/">eventproxy 源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/fe-event-loop/">JavaScript 和 NodeJS 事件循环</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/03/javascript-event-loop/">什么是JavaScript 事件循环 ?</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/27/mongoose-tutorial-2/">Mongoose 学习笔记二 — Query 和 Population</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/react-life-cycle/">React 的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/ngrok/">使用ngrok让你的本地mock可以提供给外网访问</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/redux-introduction/">Redux 简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/regular-expression/">JavaScript中的正则表达式之正向环视(正向断言)</a></li></ul></div><div class="widget"><div class="widget-title"><span class="icon icon-link"></span><span class="widget-txt">友情链接</span></div><ul></ul><a href="http://fex.baidu.com/" title="百度FEX" target="_blank">百度FEX</a><ul></ul><a href="http://www.aliued.com/" title="阿里巴巴UED" target="_blank">阿里巴巴UED</a><ul></ul><a href="http://f2e.souche.com/blog/" title="搜车大无线团队博客" target="_blank">搜车大无线团队博客</a><ul></ul><a href="http://fe.meituan.com/" title="美团前端团队博客" target="_blank">美团前端团队博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a>2018 </a><a href="/." rel="nofollow">~Refresh的前端之路</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="https://blog.wfuny.com/js/totop.js?v=1.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="https://blog.wfuny.com/js/fancybox.js?v=1.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="https://blog.wfuny.com/js/search.js?v=1.0.1"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4c66f02c419b1b8b035290646cd20eaf";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script>(function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><script type="text/javascript" src="https://blog.wfuny.com/js/codeblock-resizer.js?v=1.0.1"></script><script type="text/javascript" src="https://blog.wfuny.com/js/smartresize.js?v=1.0.1"></script></div></body></html>